<polymer-element name="layout-inbox">
    <template>
        <style>
        core-drawer-panel /deep/ #drawer,
        core-drawer-panel /deep/ #main #scrim {
            z-index: 1;
        }
        
        core-toolbar > .selection-allow {
            margin: 0;
            padding: 0;
            transform: rotateX(90deg);
            transition: transform 400ms ease-in-out;
            visibility: hidden;
            width: 0;
            will-change: transform;
        }
        
        core-toolbar > .selection-deny {
            margin: 0;
        }
        
        core-toolbar > paper-icon-button[icon="arrow-back"] {
            transform: translateX(-42px) rotateX(0);
        }
        
        core-toolbar.selection > .selection-allow {
            padding: 8px;
            transform: rotateX(0);
            visibility: visible;
            width: auto;
        }
        
        core-toolbar.selection > .selection-deny {
            display: none;
        }
        
        core-toolbar.selection > paper-icon-button[icon="arrow-back"] {
            transform: translateX(0) rotateX(0);
        }
        
        #refresh {
            opacity: 0;
            pointer-events: none;
            position: absolute;
            will-change: opacity, transform;
            z-index: 1;
        }
        
        #refresh > div {
            background: white;
            border-radius: 50%;
            height: 22px;
            padding: 8px;
            width: 22px;
        }
        
        #refresh paper-spinner {
            height: 100%;
            width: 100%;
        }
        
        #refresh.reset {
            opacity: 0!important;
            -webkit-transform: translate3d(0, 0, 0)!important;
            transform: translate3d(0, 0, 0)!important;
        }
        
        .input-text {
            background: transparent;
            border: none;
            font-size: 16px;
            outline: none;
        }
        
        .menu-b {
            bottom: 14px;
            position: fixed;
            right: 14px;
            -webkit-transition: -webkit-transform 0.2s ease-in-out;
            transition: transform 0.2s ease-in-out;
            will-change: transform;
        }
        
        .menu-b.move-down {
            transform: translate3d(0, 480px, 0);
        }
        
        .menu-b.move-up {
            transform: translate3d(0, -48px, 0);
        }
        </style>

        <core-drawer-panel id="drawerPanel">
            <core-header-panel drawer style="background: white;">
                <div class="padding-4"></div>

                <template if="{{user.email != 'user@host'}}">
                    <div class="menu-l" horizontal justified layout on-tap="{{cPanelTap}}">
                        <div class="padding-4" self-start>
                            <selectable-icon iconImgSrc="{{user.picture ? user.picture : '/img/user.png'}}"></selectable-icon>
                        </div>
                        <div class="padding-4" flex layout vertical>
                            <div auto-vertical class="title capitalize">{{user.name}}</div>
                            <div auto-vertical class="description">{{user.email}}</div>
                        </div>
                    </div>

                    <div class="padding-4"></div>
                </template>

                <template repeat="{{list}}">
                    <div class="menu-l" horizontal justified layout on-tap="{{menuKeywordTap}}" tag="{{_id}}">
                        <div class="padding-4" self-start>
                            <selectable-icon iconClass="{{icon.class}}" iconText="{{icon.text}}"></selectable-icon>
                        </div>
                        <div class="padding-4" flex layout vertical>
                            <div auto-vertical horizontal justified layout>
                                <div class="title overflow-hidden lowercase" flex style="width: 32px!important;">{{keyword}}</div>
                                <div class="badge" self-start>{{torrent_out.length ? torrent_out.length : "#"}}</div>
                            </div>
                            <div auto-vertical class="description"><b>{{seeds}}</b> S / <b>{{peers}}</b> P</div>
                        </div>
                    </div>
                </template>

                <div class="padding-4"></div>

                <div class="menu-l" horizontal justified layout on-tap="{{open_github_source}}">
                    <div class="padding-4" self-start>
                        <selectable-icon iconImgSrc="/img/github.png"></selectable-icon>
                    </div>
                    <div class="padding-4" flex layout vertical>
                        <div auto-vertical class="title">open source</div>
                        <div auto-vertical class="description">build break develop</div>
                    </div>
                </div>

                <div class="padding-4"></div>
            </core-header-panel>

            <core-header-panel id="main" main on-trackend="{{refresh_trackend}}" on-trackstart="{{refresh_trackstart}}" on-tracky="{{refresh_tracky}}">
                <core-toolbar class="{{listSelected.length ? 'grey-500' : toolBar.class}} {{ {'selection': listSelected.length} | tokenList }}" id="mainToolBar">
                    <paper-icon-button class="selection-allow" icon="arrow-back" on-tap="{{deSelectAll}}"></paper-icon-button>
                    <paper-icon-button class="selection-deny" icon="menu" on-tap="{{menuToggle}}"></paper-icon-button>
                    <div flex>{{listSelected.length ? listSelected.length : toolBar.text}}</div>
                    <paper-icon-button class="selection-allow" icon="delete" on-tap="{{deleteSelectedTap}}"></paper-icon-button>
                    <paper-icon-button class="selection-allow" icon="social:share" on-tap="{{shareSelectedTap}}"></paper-icon-button>
                    <paper-icon-button class="selection-allow" icon="more-vert" on-tap="{{moreTap}}"></paper-icon-button>
                    <paper-icon-button class="selection-deny" icon="search" on-tap="{{searchBarToggle}}"></paper-icon-button>
                    <div center-center class="bottom fit" horizontal id="refresh" layout>
                        <div class="paper-shadow-bottom-z-1">
                            <paper-spinner active id="refresh_spinner"></paper-spinner>
                        </div>
                    </div>
                </core-toolbar>
                <core-animated-pages fit notap selected="{{page}}" transitions="slide-from-right">
                    <section>
                        <div center-justified fit horizontal layout>
                            <div class="disabled-text" self-center>Empty ..</div>
                        </div>
                    </section>
                    <section touch-action="pan-x pan-y">
                        <core-selector multi excludedLocalNames="div" selected="{{listSelected}}" selectedAttribute="selected" valueattr="tag">
                            <template repeat="{{list}}">
                                <template if="{{!hidden}}">
                                    <div center-justified horizontal layout>
                                        <div class="li" layout vertical>
                                            <div horizontal justified layout>
                                                <input class="input-text" disabled flex tag="{{_id}}" type="text" value="{{keyword}}">
                                                <div self-start>
                                                    <paper-icon-button icon="close" on-tap="{{deleteKeywordTap}}" tag="{{_id}}"></paper-icon-button>
                                                </div>
                                            </div>
                                            <paper-progress hidden?="{{torrent_out.length}}" indeterminate style="width: 100%;"></paper-progress>
                                        </div>
                                    </div>
                                    <template repeat="{{item in torrent_out}}">
                                        <inbox-item item="{{item}}" tag="{{item._id}}"></inbox-item>
                                    </template>
                                </template>
                            </template>
                        </core-selector>
                        <div horizontal layout style="padding: 42px;"></div>
                    </section>
                </core-animated-pages>
            </core-header-panel>
        </core-drawer-panel>

        <paper-fab class="menu-b {{ {'move-down': listSelected.length} | tokenList }}" icon="add" on-tap="{{addKeywordFabTap}}"></paper-fab>

        <paper-dialog backdrop id="addKeyword" transition="core-transition-bottom">
            <div layout vertical>
                <div layout class="padding-24" vertical>
                    <div style="border-bottom: 2px solid #888; padding: 4px 0;">add to scheduler</div>
                    <div class="padding-4"></div>
                    <paper-input autoFocus label="keyword" value="{{keyword}}"></paper-input>
                    <div center horizontal justified layout>
                        <div>min peer count</div>
                        <paper-slider editable flex id="peers" max="1000" min="1" value="{{peers}}"></paper-slider>
                    </div>
                    <div center horizontal justified layout>
                        <div>min seed count</div>
                        <paper-slider editable flex id="seeds" max="1000" min="1" value="{{seeds}}"></paper-slider>
                    </div>
                </div>
                <div class="paper-dialog-title" horizontal layout reverse>
                    <paper-button core-overlay-toggle on-tap="{{addKeywordOk}}">
                        <core-icon icon="check"></core-icon>&nbsp;&nbsp;Ok
                    </paper-button>
                    <paper-button core-overlay-toggle>
                        <core-icon icon="clear"></core-icon>&nbsp;&nbsp;Cancel
                    </paper-button>
                </div>
            </div>
        </paper-dialog>

        <paper-dialog backdrop id="deleteKeyword" transition="core-transition-bottom">
            <div layout vertical>
                <div class="padding-24">Are you sure to delete this item ?</div>
                <div class="paper-dialog-title" horizontal layout reverse>
                    <paper-button core-overlay-toggle on-tap="{{deleteKeywordOk}}">
                        <core-icon icon="check"></core-icon>&nbsp;&nbsp;Ok
                    </paper-button>
                    <paper-button core-overlay-toggle>
                        <core-icon icon="clear"></core-icon>&nbsp;&nbsp;Cancel
                    </paper-button>
                </div>
            </div>
        </paper-dialog>

        <paper-dialog backdrop id="cPanel" transition="core-transition-bottom">
            <div layout vertical>
                <div layout class="padding-24" vertical>
                    <div style="border-bottom: 2px solid #888; padding: 4px 0;">alerter</div>
                    <div class="padding-4"></div>
                    <div center class="disabled-text" horizontal justified layout style="padding: 8px 0;">
                        <div>enable GCM</div>
                        <paper-toggle-button checked disabled></paper-toggle-button>
                    </div>
                    <div center class="disabled-text" horizontal justified layout style="padding: 8px 0;">
                        <div>enable email alert</div>
                        <paper-toggle-button disabled></paper-toggle-button>
                    </div>
                    <div class="padding-4"></div>
                    <div style="border-bottom: 2px solid #888; padding: 4px 0;">scheduler</div>
                    <div class="padding-4"></div>
                    <div center class="disabled-text" horizontal justified layout>
                        <div>frequency / day</div>
                        <paper-slider disabled editable flex id="seeds" max="1000" min="1" value="2"></paper-slider>
                    </div>
                    <div class="padding-4"></div>
                    <div style="border-bottom: 2px solid #888; padding: 4px 0;">user: <span class="lowercase">{{user.name}}</span></div>
                    <div class="padding-4"></div>
                    <div horizontal layout reverse>
                        <paper-button core-overlay-toggle on-tap="{{signOut}}">signOut</paper-button>
                    </div>
                </div>
            </div>
        </paper-dialog>

        <search-bar id="search"></search-bar>

        <paper-toast duration="4000" id="toast" on-core-overlay-open="{{on_core_overlay_open}}">
            <div hidden?="{{undo.length < 1}}" on-tap="{{undoTap}}" style="color: #FFEB3B;">undo</div>
        </paper-toast>
    </template>

    <script>
    Polymer("layout-inbox", {

        page: 1,

        toolBar: {
            class: "teal-500",
            text: "Torrent Alert"
        },

        refresh: false,
        refresh_max_y: 80,

        user: {
            email: "user@host",
            name: "user",
            picture: "/img/user.png"
        },

        list: [],
        listSelected: [],

        torrent_out_queue: [],

        keyword: "",
        peers: 100,
        seeds: 10,

        deleteKeywordID: "",
        undo: [],

        addKeywordFabTap: function() {
            this.$.addKeyword.opened = true;
        },

        addKeywordOk: function() {
            this.keyword = decodeURIComponent(this.keyword).trim();
            var keywordArray = (this.keyword.split("/").filter(Boolean).reverse()[0] || "").trim().split(/\?[fq]=/g);

            if (this.keyword.length) {
                var _this = this,
                    row = {
                        keyword: (1 < keywordArray.length) ? keywordArray[1] : keywordArray[0],
                        peers: parseInt(this.peers),
                        seeds: parseInt(this.seeds),
                        urlPart: (1 < keywordArray.length) ? keywordArray[0] : "search"
                    };

                Meteor.call("insert_torrent_in", row, function(error, status) {
                    if (error) {
                        console.log(error);
                    } else {
                        if (status) {
                            _this.toastAlert("1 keyword added");
                        } else {
                            _this.toastAlert("quota limit reached");
                        }
                    }
                });
            } else {
                this.toastAlert("empty keyword");
            }

            this.keyword = "";
            this.peers = 100;
            this.seeds = 10;
        },

        cPanelTap: function() {
            this.$.drawerPanel.closeDrawer();

            this.$.cPanel.opened = true;
        },

        deleteKeywordOk: function() {
            var _this = this,
                index = -1;

            var item = _.find(_this.list, function(item) {
                index++;

                return (item._id == _this.deleteKeywordID);
            });

            if (item) {
                _this.list.splice(index, 1);

                Meteor.call("remove_torrent_in", _this.deleteKeywordID, function(error, status) {
                    if (error) {
                        console.log(error);
                    } else {
                        _this.toastAlert("1 keyword deleted");
                    }
                });

                for (var A = 0; A < _this.list.length; A++) {
                    _this.list[A].hidden = false;
                }

                _this.toolBar.class = "teal-500";
            }
        },

        deleteKeywordTap: function(event, detail, sender) {
            this.deleteKeywordID = $(sender).attr("tag");

            this.$.deleteKeyword.opened = true;
        },

        deleteSelectedTap: function() {
            var _this = this;

            _this.listSelected.forEach(function(_id) {
                for (var A = 0; A < _this.list.length; A++) {
                    var index = -1;

                    var item = _.find(_this.list[A].torrent_out, function(item) {
                        index++;

                        return (_id == item._id);
                    });

                    if (item) {
                        _this.list[A].torrent_out[index].list_class = "hidden";

                        break;
                    }
                }
            });

            _this.undo = _this.listSelected;
            _this.listSelected = [];

            _this.toastAlert(_this.undo.length + " item" + (_this.undo.length == 1 ? "" : "s") + " removed");
        },

        deSelectAll: function() {
            this.listSelected = [];
        },

        domReady: function() {
            var _this = this;

            Meteor.autorun(function() {
                if (Meteor.status().connected) {
                    if (_this.$.toast.text != "server connected") {
                        _this.toastAlert("server connected");
                    }
                } else {
                    if ( /* _this.$.toast.text && */ _this.$.toast.text != "lost server connection") {
                        _this.toastAlert("lost server connection");
                    }
                }

                if (Meteor.user()) {
                    _this.user = Meteor.user().profile;
                } else {
                    _this.user = {
                        email: "user@host",
                        name: "user",
                        picture: "/img/user.png"
                    };
                }
            });

            this.list = JSON.parse($("#torrentz_db").val());

            torrent_in.find().observeChanges({
                added: function(_id, row) {
                    var item = _.find(_this.list, function(item) {
                        return (_id == item._id);
                    });

                    if (typeof(item) == "undefined") {
                        _this.list.push($.extend(true, row, {
                            _id: _id,
                            icon: {
                                class: polymer_color(row.keyword),
                                text: (isNaN(row.keyword.charAt(0)) ? row.keyword.charAt(0) : "#")
                            },
                            torrent_out: []
                        }));

                        _.debounce(function() {
                            _this.list = _.sortBy(_this.list, "keyword");

                            Meteor.subscribe("torrent_out", {
                                torrent_in: _.map(_this.list, function(item) {
                                    return item._id;
                                })
                            });
                        }, 4000)();
                    }
                },

                removed: function(_id) {
                    var index = -1;

                    var item = _.find(_this.list, function(item) {
                        index++;

                        return (_id == item._id);
                    });

                    if (item) {
                        _this.list.splice(index, 1);
                    }
                }
            });

            torrent_out.find().observeChanges({
                added: function(_id, row) {
                    var group_index = -1;

                    var group = _.find(_this.list, function(item) {
                        group_index++;

                        return (-1 < row.torrent_in.indexOf(item._id));
                    });

                    if (group) {
                        var index = -1;

                        var item = _.find(_this.list[group_index].torrent_out, function(item) {
                            index++;

                            return (_id == item._id);
                        });

                        if (typeof(item) == "undefined") {
                            if (_this.list[group_index].peers <= row.peers && _this.list[group_index].seeds <= row.seeds) {
                                _this.list[group_index].torrent_out.push($.extend(true, row, {
                                    _id: _id,
                                    category_class: polymer_color(row.category, true),
                                    list_class: "item"
                                }));

                                _this.torrent_out_queue.push(group_index);

                                _.debounce(function() {
                                    _this.torrent_out_queue = _.uniq(_this.torrent_out_queue);

                                    for (var A = 0; A < _this.torrent_out_queue.length; A++) {
                                        var Z = _this.torrent_out_queue.pop();
                                        _this.list[Z].torrent_out = _.sortBy(_this.list[Z].torrent_out, "time").reverse();
                                    }
                                }, 8000)();
                            }
                        } else {
                            if (row.peers < _this.list[group_index].peers && row.seeds < _this.list[group_index].seeds) {
                                _this.list[group_index].torrent_out.splice(index, 1);
                            }
                        }
                    }
                },

                changed: function(_id, row) {
                    var row = torrent_out.findOne({
                        _id: _id
                    });

                    var group_index = -1;

                    var group = _.find(_this.list, function(item) {
                        group_index++;

                        return (-1 < row.torrent_in.indexOf(item._id));
                    });

                    if (group) {
                        var index = -1;

                        var item = _.find(_this.list[group_index].torrent_out, function(item) {
                            index++;

                            return (_id == item._id);
                        });

                        if (item) {
                            if (row.peers < _this.list[group_index].peers && row.seeds < _this.list[group_index].seeds) {
                                _this.list[group_index].torrent_out.splice(index, 1);
                            } else {
                                _this.list[group_index].torrent_out[index] = $.extend(true, _this.list[group_index].torrent_out[index], row);
                            }
                        }
                    }
                },

                removed: function(_id) {
                    for (var A = 0; A < _this.list.length; A++) {
                        var index = -1;

                        var item = _.find(_this.list[A].torrent_out, function(item) {
                            index++;

                            return (_id == item._id);
                        });

                        if (item) {
                            _this.list[A].torrent_out.splice(index, 1);

                            break;
                        }
                    }
                }
            });

            // $(window).on("beforeunload", function() {
            //     _this.save();

            //     // return "Are you sure you want to exit ?";
            // });

            // $("html /deep/ .input-text").change(function() {
            //     console.log($(_this).attr("tag"), $(_this).val());
            // });
        },

        getList: function() {
            return this.list;
        },

        listChanged: function() {
            if (!(this.list instanceof Array)) {
                this.list = JSON.parse(this.list);
            }

            if (this.list.length == 0) {
                this.page = 0;
            } else {
                this.page = 1;
            }

            // console.log(this.list);
        },

        menuKeywordTap: function(event, opened, sender) {
            var _id = $(sender).attr("tag");

            for (var A = 0; A < this.list.length; A++) {
                if (_id == this.list[A]._id) {
                    this.list[A].hidden = false;
                    this.toolBar.class = this.list[A].icon.class;
                } else {
                    this.list[A].hidden = true;
                }
            }

            this.$.drawerPanel.closeDrawer();
        },

        menuToggle: function() {
            if (this.$.drawerPanel.narrow && $(this.$.drawerPanel).width() < parseInt(this.$.drawerPanel.responsiveWidth)) {
                this.$.drawerPanel.togglePanel();
            } else {
                this.$.drawerPanel.forceNarrow = !this.$.drawerPanel.forceNarrow;
            }
        },

        moreTap: function() {
            this.toastAlert("client/server downloading, streaming, etc");
        },

        on_core_overlay_open: function(event, opened, sender) {
            if (opened) {
                if (this.listSelected.length == 0) {
                    $("html /deep/ .menu-b").addClass("move-up");
                }
            } else {
                $("html /deep/ .menu-b").removeClass("move-up");

                if (this.undo.length) {
                    var _this = this;

                    _this.undo.forEach(function(_id) {
                        for (var A = 0; A < _this.list.length; A++) {
                            var index = -1;

                            var item = _.find(_this.list[A].torrent_out, function(item) {
                                index++;

                                return (_id == item._id);
                            });

                            if (item) {
                                _this.list[A].torrent_out.splice(index, 1);

                                Meteor.call("remove_torrent_out", _id, function(error, status) {
                                    if (error) {
                                        console.log(error);
                                    }
                                });

                                break;
                            }
                        }
                    });

                    _this.undo = [];
                }
            }
        },

        open_github_source: function() {
            window.open("http://github.com/HedCET/torrentzAlert", "_system");
        },

        refresh_trackend: function(event, detail, sender) {
            if (80 <= event.dy) {
                this.refresh = true;

                var _this = this;

                Meteor.setTimeout(function() {
                    _this.refresh = false;
                    _this.$.refresh.classList.add("reset");
                }, 4000);
            } else {
                this.refresh = false;
                this.$.refresh.classList.add("reset");
            }
        },

        refresh_trackstart: function(event, detail, sender) {
            // if (this.$.main.scroller.scrollTop == 0 && 0 < event.yDirection) {
            this.$.refresh.classList.remove("reset");
            // }
        },

        refresh_tracky: function(event, detail, sender) {
            if (!this.refresh) {
                this.$.refresh.style.opacity = Math.min(1, 1 - ((this.refresh_max_y - event.dy) / this.refresh_max_y));
                this.$.refresh.style.transform = this.$.refresh.style.webkitTransform = "translate3d(0, " + Math.min(event.dy, this.refresh_max_y) + "px, 0)";
            }
        },

        save: function() {
            $("#polymer_color_db").val(JSON.stringify(polymer_color_db));

            for (var A = 0; A < this.list.length; A++) {
                delete this.list[A].hidden;
            }

            $("#torrentz_db").val(JSON.stringify(this.list));
        },

        searchBarToggle: function() {
            this.$.search.toggle();
        },

        shareSelectedTap: function() {
            var _this = this,
                body = "";

            for (var A = 0; A < _this.listSelected.length; A++) {
                for (var B = 0; B < _this.list.length; B++) {
                    var index = -1;

                    var item = _.find(_this.list[B].torrent_out, function(item) {
                        index++;

                        return (_this.listSelected[A] == item._id);
                    });

                    if (item) {
                        if (_this.list[B].torrent_out[index].linkz.length) {
                            body += "\n\n" + (A + 1) + "\t\t" + _this.list[B].torrent_out[index].title + "\n\n";

                            _this.list[B].torrent_out[index].linkz = _.sortBy(_this.list[B].torrent_out[index].linkz, "time");

                            for (var C = 0; C < _this.list[B].torrent_out[index].linkz.length; C++) {
                                body += "\t\t" + (C + 1) + "\t\t" + _this.list[B].torrent_out[index].linkz[C].url.replace("//", "") + "\n\n";
                            }
                        }

                        break;
                    }
                }
            }

            if (body != "") {
                if (Meteor.isCordova) {
                    window.plugins.socialsharing.share("Hi\n\nTorrent Alert - " + _this.user.name + " shared " + _this.listSelected.length + ((_this.listSelected.length == 1) ? " torrent" : " torrentz") + body);
                } else {
                    window.open("mailto:" + _this.user.email + "?subject=" + encodeURIComponent("Torrent Alert") + "&body=" + encodeURIComponent("Hi\n\n" + _this.user.name + " shared " + _this.listSelected.length + " torrent" + (_this.listSelected.length == 1 ? "" : "s") + body), "_system");
                }
            } else {
                _this.toastAlert("empty email body");
            }
        },

        toastAlert: function(alert) {
            this.$.toast.opened = false;

            var _this = this;

            Meteor.setTimeout(function() {
                _this.$.toast.text = alert;
                _this.$.toast.opened = true;
            }, 400);
        },

        signOut: function() {
            var _this = this;

            Meteor.logout(function(error) {
                if (error) {
                    _this.toastAlert(error);
                } else {
                    _this.list = [];
                    $("#torrentz_db").val("[]");

                    Session.set("view", "signIn");
                }
            });
        },

        undoTap: function() {
            var _this = this;

            _this.undo.forEach(function(_id) {
                for (var A = 0; A < _this.list.length; A++) {
                    var index = -1;

                    var item = _.find(_this.list[A].torrent_out, function(item) {
                        index++;

                        return (_id == item._id);
                    });

                    if (item) {
                        _this.list[A].torrent_out[index].list_class = "item";

                        break;
                    }
                }
            });

            _this.undo = [];
        }

    });
    </script>
</polymer-element>
